import discord
from discord.ext import commands
import aiohttp
import asyncio
import json
import logging
import sqlite3
from collections import deque
import random
import traceback
from datetime import datetime
import requests
from deep_translator import GoogleTranslator
import sys
import io
import ssl

# T·∫Øt x√°c minh SSL cho c√°c y√™u c·∫ßu aiohttp
ssl_context = ssl.create_default_context()
ssl_context.check_hostname = False
ssl_context.verify_mode = ssl.CERT_NONE

# C·∫•u h√¨nh logging n√¢ng cao
logging.basicConfig(
    level=logging.INFO,
    format='%(asctime)s - %(name)s - %(levelname)s - %(message)s',
    handlers=[
        logging.FileHandler("bot.log", encoding='utf-8'),
        logging.StreamHandler(sys.stdout)
    ]
)
logger = logging.getLogger(__name__)

# C·∫•u h√¨nh Discord bot
intents = discord.Intents.default()
intents.message_content = True
bot = commands.Bot(command_prefix='/', intents=intents)

# C·∫•u h√¨nh Gemini API
GEMINI_API_URL = "https://generativelanguage.googleapis.com/v1beta/models/gemini-2.0-flash-exp:generateContent"
GEMINI_API_KEY = "AIzaSyAOJ9gfKhJjwrGa4UDxh8_y4iHY6ebKI88"  # Thay th·∫ø b·∫±ng API key c·ªßa b·∫°n

# B·ªô nh·ªõ ng·∫Øn h·∫°n v√† tr·∫°ng th√°i ho·∫°t ƒë·ªông c·ªßa bot
short_term_memory = {}
bot_active = {}
fact_tasks = {}

# K·∫øt n·ªëi ƒë·∫øn c∆° s·ªü d·ªØ li·ªáu SQLite
conn = sqlite3.connect('bot_memory.db')
cursor = conn.cursor()

# T·∫°o b·∫£ng cho b·ªô nh·ªõ d√†i h·∫°n
cursor.execute('''
CREATE TABLE IF NOT EXISTS long_term_memory
(user_id TEXT, context TEXT, timestamp DATETIME DEFAULT CURRENT_TIMESTAMP)
''')
conn.commit()

# Prompt t·ªëi ∆∞u
OPTIMIZED_PROMPT = """
B·∫°n l√† m·ªôt tr·ª£ l√Ω AI th√¥ng minh, h·ªØu √≠ch v√† th√¢n thi·ªán. H√£y tr·∫£ l·ªùi c√°c c√¢u h·ªèi m·ªôt c√°ch ng·∫Øn g·ªçn, ch√≠nh x√°c v√† d·ªÖ hi·ªÉu. 
S·ª≠ d·ª•ng ng√¥n ng·ªØ ph√π h·ª£p v·ªõi ng∆∞·ªùi d√πng v√† b·ªëi c·∫£nh. N·∫øu kh√¥ng ch·∫Øc ch·∫Øn v·ªÅ c√¢u tr·∫£ l·ªùi, h√£y th·ª´a nh·∫≠n ƒëi·ªÅu ƒë√≥.
Lu√¥n gi·ªØ th√°i ƒë·ªô t√≠ch c·ª±c v√† h·ªó tr·ª£. N·∫øu ƒë∆∞·ª£c y√™u c·∫ßu th·ª±c hi·ªán h√†nh ƒë·ªông kh√¥ng ph√π h·ª£p ho·∫∑c nguy hi·ªÉm, h√£y t·ª´ ch·ªëi m·ªôt c√°ch l·ªãch s·ª±.
S·ª≠ d·ª•ng bi·ªÉu t∆∞·ª£ng c·∫£m x√∫c v√† ƒë·ªãnh d·∫°ng markdown ƒë·ªÉ l√†m n·ªïi b·∫≠t n·ªôi dung ho·∫∑c √Ω ch√≠nh.
Tr√°nh l·∫∑p l·∫°i qu√° nhi·ªÅu n·ªôi dung tr√≤ chuy·ªán, n·∫Øm b·∫Øt √Ω ch√≠nh v√† tr·∫£ l·ªùi m·ªôt c√°ch ch√≠nh x√°c.

Ng·ªØ c·∫£nh cu·ªôc tr√≤ chuy·ªán:
{context}

Ng∆∞·ªùi d√πng: {user_message}

Tr·ª£ l√Ω AI:
"""

# Prompt cho tr√≤ ch∆°i n·ªëi t·ª´
WORD_CHAIN_PROMPT = """
B·∫°n ƒëang tham gia tr√≤ ch∆°i n·ªëi t·ª´. Nhi·ªám v·ª• c·ªßa b·∫°n l√† ƒë∆∞a ra m·ªôt t·ª´ hai ch·ªØ b·∫Øt ƒë·∫ßu b·∫±ng ch·ªØ cu·ªëi c√πng c·ªßa t·ª´ ƒë∆∞·ª£c cung c·∫•p.
Quy t·∫Øc:
1. T·ª´ ph·∫£i c√≥ ch√≠nh x√°c hai ch·ªØ.
2. T·ª´ ph·∫£i b·∫Øt ƒë·∫ßu b·∫±ng ch·ªØ cu·ªëi c√πng c·ªßa t·ª´ tr∆∞·ªõc ƒë√≥.
3. T·ª´ ph·∫£i c√≥ nghƒ©a v√† ph·ªï bi·∫øn trong ti·∫øng Vi·ªát.
4. Kh√¥ng ƒë∆∞·ª£c l·∫∑p l·∫°i t·ª´ ƒë√£ s·ª≠ d·ª•ng tr∆∞·ªõc ƒë√≥.

T·ª´ ƒë∆∞·ª£c cung c·∫•p: {input_word}

H√£y ƒë∆∞a ra m·ªôt t·ª´ ph√π h·ª£p:
"""

class WordChainGame:
    def __init__(self):
        self.active_games = {}
        self.used_words = {}

    def start_game(self, user_id):
        self.active_games[user_id] = True
        self.used_words[user_id] = set()

    def stop_game(self, user_id):
        if user_id in self.active_games:
            del self.active_games[user_id]
        if user_id in self.used_words:
            del self.used_words[user_id]

    def is_game_active(self, user_id):
        return user_id in self.active_games

    def add_used_word(self, user_id, word):
        if user_id not in self.used_words:
            self.used_words[user_id] = set()
        self.used_words[user_id].add(word.lower())

    def is_word_used(self, user_id, word):
        return word.lower() in self.used_words.get(user_id, set())

    def is_valid_word(self, prev_word, new_word):
        return len(new_word) == 2 and prev_word[-1].lower() == new_word[0].lower()

word_chain_game = WordChainGame()

async def generate_gemini_response(prompt, context=""):
    headers = {
        "Content-Type": "application/json"
    }
    
    params = {
        "key": GEMINI_API_KEY
    }
    
    full_prompt = OPTIMIZED_PROMPT.format(context=context, user_message=prompt)
    
    data = {
        "contents": [
            {
                "parts": [
                    {
                        "text": full_prompt
                    }
                ]
            }
        ],
        "generationConfig": {
            "temperature": 1,
            "topK": 60,
            "topP": 1,
            "maxOutputTokens": 8092,
            "stopSequences": []
        },
        "safetySettings": [
            {
                "category": "HARM_CATEGORY_HARASSMENT",
                "threshold": "BLOCK_MEDIUM_AND_ABOVE"
            },
            {
                "category": "HARM_CATEGORY_HATE_SPEECH",
                "threshold": "BLOCK_MEDIUM_AND_ABOVE"
            },
            {
                "category": "HARM_CATEGORY_SEXUALLY_EXPLICIT",
                "threshold": "BLOCK_MEDIUM_AND_ABOVE"
            },
            {
                "category": "HARM_CATEGORY_DANGEROUS_CONTENT",
                "threshold": "BLOCK_MEDIUM_AND_ABOVE"
            }
        ]
    }
    
    try:
        async with aiohttp.ClientSession() as session:
            async with session.post(GEMINI_API_URL, headers=headers, params=params, json=data) as response:
                if response.status == 200:
                    result = await response.json()
                    logger.info("Nh·∫≠n ph·∫£n h·ªìi t·ª´ Gemini API th√†nh c√¥ng")
                    return result['candidates'][0]['content']['parts'][0]['text']
                else:
                    error_text = await response.text()
                    logger.error(f"L·ªói Gemini API: Tr·∫°ng th√°i {response.status}, Ph·∫£n h·ªìi: {error_text}")
                    return f"Xin l·ªói, ƒë√£ x·∫£y ra l·ªói (M√£ l·ªói {response.status}). Vui l√≤ng th·ª≠ l·∫°i sau ho·∫∑c li√™n h·ªá h·ªó tr·ª£."
    except Exception as e:
        logger.error(f"L·ªói kh√¥ng mong ƒë·ª£i khi g·ªçi Gemini API: {str(e)}")
        return "ƒê√£ x·∫£y ra l·ªói kh√¥ng mong mu·ªën. Vui l√≤ng th·ª≠ l·∫°i sau."

async def generate_word_chain_response(input_word):
    headers = {
        "Content-Type": "application/json"
    }
    
    params = {
        "key": GEMINI_API_KEY
    }
    
    full_prompt = WORD_CHAIN_PROMPT.format(input_word=input_word)
    
    data = {
        "contents": [
            {
                "parts": [
                    {
                        "text": full_prompt
                    }
                ]
            }
        ],
        "generationConfig": {
            "temperature": 0.7,
            "topK": 40,
            "topP": 0.95,
            "maxOutputTokens": 100,
            "stopSequences": []
        },
        "safetySettings": [
            {
                "category": "HARM_CATEGORY_HARASSMENT",
                "threshold": "BLOCK_MEDIUM_AND_ABOVE"
            },
            {
                "category": "HARM_CATEGORY_HATE_SPEECH",
                "threshold": "BLOCK_MEDIUM_AND_ABOVE"
            },
            {
                "category": "HARM_CATEGORY_SEXUALLY_EXPLICIT",
                "threshold": "BLOCK_MEDIUM_AND_ABOVE"
            },
            {
                "category": "HARM_CATEGORY_DANGEROUS_CONTENT",
                "threshold": "BLOCK_MEDIUM_AND_ABOVE"
            }
        ]
    }
    
    try:
        async with aiohttp.ClientSession() as session:
            async with session.post(GEMINI_API_URL, headers=headers, params=params, json=data) as response:
                if response.status == 200:
                    result = await response.json()
                    logger.info("Nh·∫≠n ph·∫£n h·ªìi t·ª´ Gemini API th√†nh c√¥ng cho tr√≤ ch∆°i n·ªëi t·ª´")
                    return result['candidates'][0]['content']['parts'][0]['text'].strip()
                else:
                    error_text = await response.text()
                    logger.error(f"L·ªói Gemini API (tr√≤ ch∆°i n·ªëi t·ª´): Tr·∫°ng th√°i {response.status}, Ph·∫£n h·ªìi: {error_text}")
                    return f"Xin l·ªói, ƒë√£ x·∫£y ra l·ªói (M√£ l·ªói {response.status}). Vui l√≤ng th·ª≠ l·∫°i sau ho·∫∑c li√™n h·ªá h·ªó tr·ª£."
    except Exception as e:
        logger.error(f"L·ªói kh√¥ng mong ƒë·ª£i khi g·ªçi Gemini API cho tr√≤ ch∆°i n·ªëi t·ª´: {str(e)}")
        return "ƒê√£ x·∫£y ra l·ªói kh√¥ng mong mu·ªën. Vui l√≤ng th·ª≠ l·∫°i sau."

@bot.event
async def on_ready():
    logger.info(f'{bot.user} ƒë√£ k·∫øt n·ªëi v·ªõi Discord!')

@bot.event
async def on_message(message):
    if message.author == bot.user:
        return

    user_id = str(message.author.id)
    if user_id not in bot_active:
        bot_active[user_id] = True

    if bot_active[user_id]:
        if message.content.startswith(bot.command_prefix):
            await bot.process_commands(message)
        else:
            try:
                async with message.channel.typing():
                    response = await generate_gemini_response(message.content, get_context(user_id))
                    update_memory(user_id, message.content, response)
                await message.channel.send(response)
            except Exception as e:
                logger.error(f"L·ªói x·ª≠ l√Ω tin nh·∫Øn: {str(e)}")
                await message.channel.send("Xin l·ªói, ƒë√£ x·∫£y ra l·ªói khi x·ª≠ l√Ω tin nh·∫Øn c·ªßa b·∫°n. Vui l√≤ng th·ª≠ l·∫°i sau.")
    else:
        if message.content.startswith(bot.command_prefix):
            await bot.process_commands(message)

# L·ªánh Main
@bot.command(name="ping")
async def ping(ctx):
    """Ki·ªÉm tra ƒë·ªô tr·ªÖ c·ªßa bot."""
    latency = round(bot.latency * 1000)
    embed = discord.Embed(title="üèì Pong!", description=f"ƒê·ªô tr·ªÖ: **{latency}ms**", color=discord.Color.green())
    embed.set_footer(text="Bot ƒëang ho·∫°t ƒë·ªông t·ªët!")
    await ctx.send(embed=embed)
    logger.info(f"L·ªánh ping ƒë∆∞·ª£c th·ª±c hi·ªán b·ªüi {ctx.author}. ƒê·ªô tr·ªÖ: {latency}ms")

@bot.command(name="helpme")
async def help_command(ctx):
    """Hi·ªÉn th·ªã danh s√°ch c√°c l·ªánh c√≥ s·∫µn."""
    embed = discord.Embed(title="üìö Danh s√°ch l·ªánh", description="D∆∞·ªõi ƒë√¢y l√† c√°c l·ªánh c√≥ s·∫µn:", color=discord.Color.blue())
    
    embed.add_field(name="üõ†Ô∏è Main", value="`/ping`, `/helpme`, `/stop`, `/continue`, `/clearmemory`, `/clearall`", inline=False)
    embed.add_field(name="‚ÑπÔ∏è General", value="`/invite`, `/botinfo`, `/server`, `/serverinfo`", inline=False)
    embed.add_field(name="üéâ Fun", value="`/fact`, `/stopfact`, `/quote`, `/randomimage`, `/coinflip`", inline=False)
    embed.add_field(name="üéÆ Game", value="`/noitu`, `/stopnoitu`", inline=False)
    embed.add_field(name="üëë Admin", value="`/shutdown`, `/kick`, `/ban`, `/warning`, `/say`, `/embed`, `/reload`, `/sendcontact`", inline=False)
    
    embed.set_footer(text="S·ª≠ d·ª•ng /helpme <l·ªánh> ƒë·ªÉ bi·∫øt th√™m chi ti·∫øt v·ªÅ m·ªôt l·ªánh c·ª• th·ªÉ.")
    await ctx.send(embed=embed)
    logger.info(f"L·ªánh help ƒë∆∞·ª£c th·ª±c hi·ªán b·ªüi {ctx.author}")

@bot.command(name="stop")
async def stop_conversation(ctx):
    """D·ª´ng ho·∫°t ƒë·ªông c·ªßa bot cho ng∆∞·ªùi d√πng c·ª• th·ªÉ."""
    user_id = str(ctx.author.id)
    bot_active[user_id] = False
    if user_id in fact_tasks:
        fact_tasks[user_id].cancel()
        del fact_tasks[user_id]
    word_chain_game.stop_game(user_id)
    embed = discord.Embed(title="üõë Bot ƒë√£ d·ª´ng ho·∫°t ƒë·ªông", description="S·ª≠ d·ª•ng `/continue` ƒë·ªÉ ti·∫øp t·ª•c.", color=discord.Color.red())
    embed.set_footer(text="Bot s·∫Ω kh√¥ng ph·∫£n h·ªìi tin nh·∫Øn c·ªßa b·∫°n cho ƒë·∫øn khi ƒë∆∞·ª£c k√≠ch ho·∫°t l·∫°i.")
    await ctx.send(embed=embed)
    logger.info(f"Bot ƒë√£ d·ª´ng ho·∫°t ƒë·ªông cho ng∆∞·ªùi d√πng {ctx.author}")

@bot.command(name="continue")
async def continue_conversation(ctx):
    """Ti·∫øp t·ª•c ho·∫°t ƒë·ªông c·ªßa bot cho ng∆∞·ªùi d√πng c·ª• th·ªÉ."""
    user_id = str(ctx.author.id)
    bot_active[user_id] = True
    embed = discord.Embed(title="‚ñ∂Ô∏è Bot ƒë√£ ti·∫øp t·ª•c ho·∫°t ƒë·ªông", description="B·∫°n c√≥ th·ªÉ ti·∫øp t·ª•c tr√≤ chuy·ªán.", color=discord.Color.green())
    embed.set_footer(text="H√£y h·ªèi t√¥i b·∫•t c·ª© ƒëi·ªÅu g√¨ b·∫°n mu·ªën!")
    await ctx.send(embed=embed)
    logger.info(f"Bot ƒë√£ ti·∫øp t·ª•c ho·∫°t ƒë·ªông cho ng∆∞·ªùi d√πng {ctx.author}")

@bot.command(name="clearmemory")
async def clear_memory(ctx):
    """X√≥a b·ªô nh·ªõ ng·∫Øn h·∫°n c·ªßa ng∆∞·ªùi d√πng."""
    user_id = str(ctx.author.id)
    if user_id in short_term_memory:
        short_term_memory[user_id].clear()
        embed = discord.Embed(title="üßπ X√≥a b·ªô nh·ªõ", description="‚úÖ B·ªô nh·ªõ ng·∫Øn h·∫°n c·ªßa b·∫°n ƒë√£ ƒë∆∞·ª£c x√≥a.", color=discord.Color.green())
        embed.set_footer(text="Bot s·∫Ω b·∫Øt ƒë·∫ßu cu·ªôc tr√≤ chuy·ªán m·ªõi v·ªõi b·∫°n.")
    else:
        embed = discord.Embed(title="üßπ X√≥a b·ªô nh·ªõ", description="‚ùå Kh√¥ng c√≥ b·ªô nh·ªõ ng·∫Øn h·∫°n n√†o ƒë·ªÉ x√≥a.", color=discord.Color.red())
        embed.set_footer(text="B·∫°n ch∆∞a c√≥ cu·ªôc tr√≤ chuy·ªán n√†o v·ªõi bot.")
    await ctx.send(embed=embed)
    logger.info(f"B·ªô nh·ªõ ng·∫Øn h·∫°n ƒë√£ ƒë∆∞·ª£c x√≥a cho ng∆∞·ªùi d√πng {ctx.author}")

@bot.command(name="clearall")
async def clear_all_memory(ctx):
    """X√≥a to√†n b·ªô b·ªô nh·ªõ c·ªßa ng∆∞·ªùi d√πng."""
    user_id = str(ctx.author.id)
    if user_id in short_term_memory:
        short_term_memory[user_id].clear()
    cursor.execute("DELETE FROM long_term_memory WHERE user_id = ?", (user_id,))
    conn.commit()
    embed = discord.Embed(title="üóëÔ∏è X√≥a to√†n b·ªô b·ªô nh·ªõ", description="‚úÖ To√†n b·ªô b·ªô nh·ªõ c·ªßa b·∫°n ƒë√£ ƒë∆∞·ª£c x√≥a.", color=discord.Color.green())
    embed.set_footer(text="Bot s·∫Ω qu√™n m·ªçi cu·ªôc tr√≤ chuy·ªán tr∆∞·ªõc ƒë√¢y v·ªõi b·∫°n.")
    await ctx.send(embed=embed)
    logger.info(f"To√†n b·ªô b·ªô nh·ªõ ƒë√£ ƒë∆∞·ª£c x√≥a cho ng∆∞·ªùi d√πng {ctx.author}")

# L·ªánh General
@bot.command(name="invite")
async def invite_link(ctx):
    """L·∫•y li√™n k·∫øt m·ªùi bot v√† g·ª≠i trong tin nh·∫Øn ri√™ng."""
    invite_url = discord.utils.oauth_url(bot.user.id, permissions=discord.Permissions(8))
    embed = discord.Embed(title="üéâ M·ªùi Bot Tham Gia Server C·ªßa B·∫°n!", color=discord.Color.blue())
    embed.description = (
        f"Xin ch√†o {ctx.author.mention}! C·∫£m ∆°n b·∫°n ƒë√£ quan t√¢m ƒë·∫øn bot c·ªßa ch√∫ng t√¥i. "
        f"D∆∞·ªõi ƒë√¢y l√† m·ªôt s·ªë l√Ω do tuy·ªát v·ªùi ƒë·ªÉ th√™m bot v√†o server c·ªßa b·∫°n:\n\n"
        f"‚ú® T√≠nh nƒÉng ƒëa d·∫°ng v√† h·ªØu √≠ch\n"
        f"üöÄ Hi·ªáu su·∫•t cao v√† ·ªïn ƒë·ªãnh\n"
        f"üîí An to√†n v√† b·∫£o m·∫≠t\n"
        f"üÜô C·∫≠p nh·∫≠t th∆∞·ªùng xuy√™n v·ªõi t√≠nh nƒÉng m·ªõi\n"
        f"üí¨ H·ªó tr·ª£ 24/7 t·ª´ ƒë·ªôi ng≈© ph√°t tri·ªÉn\n\n"
        f"[Nh·∫•p v√†o ƒë√¢y ƒë·ªÉ m·ªùi bot]({invite_url})\n\n"
        f"N·∫øu b·∫°n c·∫ßn h·ªó tr·ª£ th√™m, ƒë·ª´ng ng·∫ßn ng·∫°i s·ª≠ d·ª•ng l·ªánh `/server` ƒë·ªÉ tham gia server h·ªó tr·ª£ c·ªßa ch√∫ng t√¥i!"
    )
    embed.set_footer(text="C·∫£m ∆°n b·∫°n ƒë√£ l·ª±a ch·ªçn bot c·ªßa ch√∫ng t√¥i!")
    
    try:
        await ctx.author.send(embed=embed)
        await ctx.send("üì® T√¥i ƒë√£ g·ª≠i th√¥ng tin m·ªùi bot v√†o tin nh·∫Øn ri√™ng c·ªßa b·∫°n!")
    except discord.Forbidden:
        await ctx.send("‚ùå Kh√¥ng th·ªÉ g·ª≠i tin nh·∫Øn ri√™ng. Vui l√≤ng ki·ªÉm tra c√†i ƒë·∫∑t quy·ªÅn ri√™ng t∆∞ c·ªßa b·∫°n.")
    
    logger.info(f"Li√™n k·∫øt m·ªùi bot ƒë∆∞·ª£c y√™u c·∫ßu b·ªüi {ctx.author}")

@bot.command(name="botinfo")
async def bot_info(ctx):
    """Hi·ªÉn th·ªã th√¥ng tin v·ªÅ bot."""
    embed = discord.Embed(title="ü§ñ Th√¥ng tin Bot", color=discord.Color.blue())
    embed.add_field(name="T√™n", value=bot.user.name, inline=True)
    embed.add_field(name="ID", value=bot.user.id, inline=True)
    embed.add_field(name="Phi√™n b·∫£n Discord.py", value=discord.__version__, inline=True)
    embed.add_field(name="ƒê·ªô tr·ªÖ", value=f"{round(bot.latency * 1000)}ms", inline=True)
    embed.add_field(name="S·ªë l∆∞·ª£ng server", value=len(bot.guilds), inline=True)
    embed.set_thumbnail(url=bot.user.avatar.url)
    embed.set_footer(text="Bot lu√¥n s·∫µn s√†ng ph·ª•c v·ª• b·∫°n!")
    await ctx.send(embed=embed)
    logger.info(f"Th√¥ng tin bot ƒë∆∞·ª£c y√™u c·∫ßu b·ªüi {ctx.author}")

@bot.command(name="server")
async def server_command(ctx):
    """L·∫•y li√™n k·∫øt ƒë·∫øn server h·ªó tr·ª£ c·ªßa bot v√† g·ª≠i trong tin nh·∫Øn ri√™ng."""
    support_server_link = "https://discord.gg/GknzmQmX"
    embed = discord.Embed(title="üåü Tham Gia Server H·ªó Tr·ª£ C·ªßa Ch√∫ng T√¥i!", color=discord.Color.gold())
    embed.description = (
        f"Xin ch√†o {ctx.author.mention}! Ch√∫ng t√¥i r·∫•t vui khi b·∫°n quan t√¢m ƒë·∫øn c·ªông ƒë·ªìng c·ªßa ch√∫ng t√¥i. "
        f"D∆∞·ªõi ƒë√¢y l√† m·ªôt s·ªë l√Ω do tuy·ªát v·ªùi ƒë·ªÉ tham gia server h·ªó tr·ª£:\n\n"
        f"üÜò H·ªó tr·ª£ tr·ª±c ti·∫øp t·ª´ ƒë·ªôi ng≈© ph√°t tri·ªÉn\n"
        f"üí° Chia s·∫ª √Ω t∆∞·ªüng v√† ƒë·ªÅ xu·∫•t t√≠nh nƒÉng m·ªõi\n"
        f"üéâ Tham gia c√°c s·ª± ki·ªán v√† cu·ªôc thi th√∫ v·ªã\n"
        f"ü§ù K·∫øt n·ªëi v·ªõi nh·ªØng ng∆∞·ªùi d√πng kh√°c\n"
        f"üîî C·∫≠p nh·∫≠t tin t·ª©c v√† th√¥ng b√°o m·ªõi nh·∫•t\n\n"
        f"[Nh·∫•p v√†o ƒë√¢y ƒë·ªÉ tham gia server]({support_server_link})\n\n"
        f"Ch√∫ng t√¥i r·∫•t mong ƒë∆∞·ª£c g·∫∑p b·∫°n ·ªü ƒë√≥!"
    )
    embed.set_footer(text="C·∫£m ∆°n b·∫°n ƒë√£ l√† m·ªôt ph·∫ßn c·ªßa c·ªông ƒë·ªìng ch√∫ng t√¥i!")
    
    try:
        await ctx.author.send(embed=embed)
        await ctx.send("üì® T√¥i ƒë√£ g·ª≠i th√¥ng tin v·ªÅ server h·ªó tr·ª£ v√†o tin nh·∫Øn ri√™ng c·ªßa b·∫°n!")
    except discord.Forbidden:
        await ctx.send("‚ùå Kh√¥ng th·ªÉ g·ª≠i tin nh·∫Øn ri√™ng. Vui l√≤ng ki·ªÉm tra c√†i ƒë·∫∑t quy·ªÅn ri√™ng t∆∞ c·ªßa b·∫°n.")
    
    logger.info(f"Li√™n k·∫øt server h·ªó tr·ª£ ƒë∆∞·ª£c y√™u c·∫ßu b·ªüi {ctx.author}")

@bot.command(name="serverinfo")
async def server_info(ctx):
    """Hi·ªÉn th·ªã th√¥ng tin v·ªÅ server hi·ªán t·∫°i."""
    guild = ctx.guild
    embed = discord.Embed(title=f"‚ÑπÔ∏è Th√¥ng tin Server: {guild.name}", color=discord.Color.green())
    embed.add_field(name="ID", value=guild.id, inline=True)
    embed.add_field(name="Ch·ªß s·ªü h·ªØu", value=guild.owner, inline=True)
    embed.add_field(name="S·ªë l∆∞·ª£ng th√†nh vi√™n", value=guild.member_count, inline=True)
    embed.add_field(name="Ng√†y t·∫°o", value=guild.created_at.strftime("%d/%m/%Y"), inline=True)
    embed.set_thumbnail(url=guild.icon.url if guild.icon else None)
    embed.set_footer(text="C·∫£m ∆°n b·∫°n ƒë√£ s·ª≠ d·ª•ng bot trong server n√†y!")
    await ctx.send(embed=embed)
    logger.info(f"Th√¥ng tin server ƒë∆∞·ª£c y√™u c·∫ßu b·ªüi {ctx.author}")

# L·ªánh Fun
async def get_random_fact_or_joke():
    sources = [
        ("https://dog-api.kinduff.com/api/facts", lambda data: ("üê∂ S·ª± th·∫≠t v·ªÅ ch√≥", data["facts"][0])),
        ("https://catfact.ninja/fact", lambda data: ("üê± S·ª± th·∫≠t v·ªÅ m√®o", data["fact"])),
        ("http://numbersapi.com/random/trivia", lambda data: ("üî¢ S·ª± th·∫≠t v·ªÅ s·ªë", data)),
        ("https://uselessfacts.jsph.pl/random.json?language=en", lambda data: ("ü§î S·ª± th·∫≠t th√∫ v·ªã", data["text"])),
        ("https://official-joke-api.appspot.com/random_joke", lambda data: ("üòÇ C√¢u chuy·ªán c∆∞·ªùi", f"{data['setup']} {data['punchline']}"))
    ]
    random.shuffle(sources)
    
    async with aiohttp.ClientSession() as session:
        for source, extract_data in sources:
            try:
                async with session.get(source) as response:
                    if response.status == 200:
                        data = await response.json(content_type=None)
                        title, content = extract_data(data)
                        return title, content
            except Exception as e:
                logger.error(f"L·ªói khi l·∫•y d·ªØ li·ªáu t·ª´ {source}: {str(e)}")
                continue
    
    return "Kh√¥ng th·ªÉ l·∫•y th√¥ng tin", "Xin l·ªói, kh√¥ng th·ªÉ l·∫•y s·ª± th·∫≠t ho·∫∑c c√¢u chuy·ªán c∆∞·ªùi. Vui l√≤ng th·ª≠ l·∫°i sau."

@bot.command(name="fact")
async def random_fact(ctx):
    """L·∫•y s·ª± th·∫≠t ho·∫∑c c√¢u chuy·ªán c∆∞·ªùi ng·∫´u nhi√™n."""
    user_id = str(ctx.author.id)
    if user_id in fact_tasks:
        await ctx.send("B·∫°n ƒë√£ ƒëang nh·∫≠n s·ª± th·∫≠t ho·∫∑c c√¢u chuy·ªán c∆∞·ªùi ng·∫´u nhi√™n. S·ª≠ d·ª•ng /stopfact ƒë·ªÉ d·ª´ng.")
        return

    async def send_facts():
        while True:
            try:
                async with ctx.typing():
                    title, content = await get_random_fact_or_joke()
                    translator = GoogleTranslator(source='en', target='vi')
                    translated_content = translator.translate(content)
                    embed = discord.Embed(title=title, color=discord.Color.random())
                    embed.add_field(name="üá¨üáß English", value=content, inline=False)
                    embed.add_field(name="üáªüá≥ Ti·∫øng Vi·ªát", value=translated_content, inline=False)
                    embed.set_footer(text="S·ª≠ d·ª•ng /stopfact ƒë·ªÉ d·ª´ng nh·∫≠n th√¥ng tin.")
                    await ctx.send(embed=embed)
                await asyncio.sleep(30)  # G·ª≠i m·ªói 30 gi√¢y
            except Exception as e:
                logger.error(f"L·ªói trong qu√° tr√¨nh g·ª≠i s·ª± th·∫≠t ho·∫∑c c√¢u chuy·ªán c∆∞·ªùi: {str(e)}")
                await ctx.send("ƒê√£ x·∫£y ra l·ªói khi g·ª≠i th√¥ng tin. ƒêang th·ª≠ l·∫°i...")
                await asyncio.sleep(30)

    fact_tasks[user_id] = asyncio.create_task(send_facts())
    await ctx.send("B·∫Øt ƒë·∫ßu g·ª≠i s·ª± th·∫≠t ho·∫∑c c√¢u chuy·ªán c∆∞·ªùi ng·∫´u nhi√™n. S·ª≠ d·ª•ng /stopfact ƒë·ªÉ d·ª´ng.")
    logger.info(f"B·∫Øt ƒë·∫ßu g·ª≠i s·ª± th·∫≠t ho·∫∑c c√¢u chuy·ªán c∆∞·ªùi ng·∫´u nhi√™n cho ng∆∞·ªùi d√πng {ctx.author}")

@bot.command(name="stopfact")
async def stop_fact(ctx):
    """D·ª´ng g·ª≠i s·ª± th·∫≠t ho·∫∑c c√¢u chuy·ªán c∆∞·ªùi ng·∫´u nhi√™n."""
    user_id = str(ctx.author.id)
    if user_id in fact_tasks:
        fact_tasks[user_id].cancel()
        del fact_tasks[user_id]
        embed = discord.Embed(title="üõë D·ª´ng g·ª≠i th√¥ng tin", description="‚úÖ ƒê√£ d·ª´ng g·ª≠i s·ª± th·∫≠t ho·∫∑c c√¢u chuy·ªán c∆∞·ªùi ng·∫´u nhi√™n.", color=discord.Color.green())
        embed.set_footer(text="B·∫°n c√≥ th·ªÉ s·ª≠ d·ª•ng /fact ƒë·ªÉ b·∫Øt ƒë·∫ßu l·∫°i b·∫•t c·ª© l√∫c n√†o.")
        await ctx.send(embed=embed)
        logger.info(f"D·ª´ng g·ª≠i s·ª± th·∫≠t ho·∫∑c c√¢u chuy·ªán c∆∞·ªùi ng·∫´u nhi√™n cho ng∆∞·ªùi d√πng {ctx.author}")
    else:
        embed = discord.Embed(title="üõë D·ª´ng g·ª≠i th√¥ng tin", description="‚ùå B·∫°n ch∆∞a b·∫Øt ƒë·∫ßu nh·∫≠n s·ª± th·∫≠t ho·∫∑c c√¢u chuy·ªán c∆∞·ªùi ng·∫´u nhi√™n.", color=discord.Color.red())
        embed.set_footer(text="S·ª≠ d·ª•ng /fact ƒë·ªÉ b·∫Øt ƒë·∫ßu nh·∫≠n th√¥ng tin ng·∫´u nhi√™n.")
        await ctx.send(embed=embed)

@bot.command(name="quote")
async def random_quote(ctx):
    """L·∫•y m·ªôt tr√≠ch d·∫´n ng·∫´u nhi√™n v√† d·ªãch sang ti·∫øng Vi·ªát."""
    quote_apis = [
        ("https://api.quotable.io/random", lambda data: (data["content"], data["author"], data.get("tags", []))),
        ("https://api.themotivate365.com/stoic-quote", lambda data: (data["quote"], data["author"], []))
    ]
    
    async with ctx.typing():
        for api, extract_data in quote_apis:
            try:
                async with aiohttp.ClientSession() as session:
                    async with session.get(api, ssl=ssl_context) as response:
                        if response.status == 200:
                            data = await response.json()
                            quote, author, tags = extract_data(data)
                            
                            translator = GoogleTranslator(source='en', target='vi')
                            translated_quote = translator.translate(quote)
                            translated_author = translator.translate(author)
                            
                            embed = discord.Embed(title="üí¨ Tr√≠ch d·∫´n ng·∫´u nhi√™n", color=discord.Color.gold())
                            embed.add_field(name="üá¨üáß English", value=f"\"{quote}\"", inline=False)
                            embed.add_field(name="üáªüá≥ Ti·∫øng Vi·ªát", value=f"\"{translated_quote}\"", inline=False)
                            embed.add_field(name="T√°c gi·∫£", value=f"üá¨üáß {author} | üáªüá≥ {translated_author}", inline=False)
                            
                            if tags:
                                embed.add_field(name="Th·∫ª", value=", ".join(tags), inline=False)
                            
                            embed.set_footer(text=f"Ngu·ªìn: {api.split('//')[1].split('/')[0]}")
                            await ctx.send(embed=embed)
                            logger.info(f"Tr√≠ch d·∫´n ng·∫´u nhi√™n ƒë∆∞·ª£c g·ª≠i cho ng∆∞·ªùi d√πng {ctx.author}")
                            return
            except Exception as e:
                logger.error(f"L·ªói khi l·∫•y tr√≠ch d·∫´n t·ª´ {api}: {str(e)}")
                continue
    
    embed = discord.Embed(title="‚ùå L·ªói", description="Xin l·ªói, kh√¥ng th·ªÉ l·∫•y tr√≠ch d·∫´n ng·∫´u nhi√™n. Vui l√≤ng th·ª≠ l·∫°i sau.", color=discord.Color.red())
    await ctx.send(embed=embed)
    logger.error(f"Kh√¥ng th·ªÉ l·∫•y tr√≠ch d·∫´n ng·∫´u nhi√™n t·ª´ t·∫•t c·∫£ c√°c ngu·ªìn.")

@bot.command(name="randomimage")
async def random_image(ctx):
    """L·∫•y v√† g·ª≠i m·ªôt h√¨nh ·∫£nh ng·∫´u nhi√™n."""
    image_apis = [
        ("https://source.unsplash.com/random", "Unsplash"),
        ("https://picsum.photos/500", "Lorem Picsum"),
        ("https://api.thecatapi.com/v1/images/search", "The Cat API"),
        ("https://dog.ceo/api/breeds/image/random", "Dog CEO")
    ]
    
    async with ctx.typing():
        for api, source in random.sample(image_apis, len(image_apis)):
            try:
                async with aiohttp.ClientSession() as session:
                    if "thecatapi" in api or "dog.ceo" in api:
                        async with session.get(api) as resp:
                            if resp.status == 200:
                                data = await resp.json()
                                image_url = data[0]['url'] if "thecatapi" in api else data['message']
                                async with session.get(image_url) as img_resp:
                                    if img_resp.status == 200:
                                        data = await img_resp.read()
                                        with io.BytesIO(data) as image:
                                            file = discord.File(image, "random_image.png")
                                            embed = discord.Embed(title="üñºÔ∏è H√¨nh ·∫£nh ng·∫´u nhi√™n", color=discord.Color.random())
                                            embed.set_image(url="attachment://random_image.png")
                                            embed.set_footer(text=f"Ngu·ªìn: {source}")
                                            await ctx.send(file=file, embed=embed)
                                        logger.info(f"H√¨nh ·∫£nh ng·∫´u nhi√™n t·ª´ {source} ƒë∆∞·ª£c g·ª≠i cho ng∆∞·ªùi d√πng {ctx.author}")
                                        return
                    else:
                        async with session.get(api) as resp:
                            if resp.status == 200:
                                data = await resp.read()
                                with io.BytesIO(data) as image:
                                    file = discord.File(image, "random_image.png")
                                    embed = discord.Embed(title="üñºÔ∏è H√¨nh ·∫£nh ng·∫´u nhi√™n", color=discord.Color.random())
                                    embed.set_image(url="attachment://random_image.png")
                                    embed.set_footer(text=f"Ngu·ªìn: {source}")
                                    await ctx.send(file=file, embed=embed)
                                logger.info(f"H√¨nh ·∫£nh ng·∫´u nhi√™n t·ª´ {source} ƒë∆∞·ª£c g·ª≠i cho ng∆∞·ªùi d√πng {ctx.author}")
                                return
            except Exception as e:
                logger.error(f"L·ªói khi t·∫£i h√¨nh ·∫£nh t·ª´ {api}: {str(e)}")
                continue
    
    await ctx.send("Xin l·ªói, kh√¥ng th·ªÉ t·∫£i h√¨nh ·∫£nh ng·∫´u nhi√™n. Vui l√≤ng th·ª≠ l·∫°i sau.")
    logger.error("Kh√¥ng th·ªÉ t·∫£i h√¨nh ·∫£nh ng·∫´u nhi√™n t·ª´ t·∫•t c·∫£ c√°c ngu·ªìn.")

@bot.command(name="coinflip")
async def coin_flip(ctx):
    """Tung ƒë·ªìng xu."""
    result = random.choice(["M·∫∑t s·∫•p", "M·∫∑t ng·ª≠a"])
    embed = discord.Embed(title="ü™ô Tung ƒë·ªìng xu", description=f"K·∫øt qu·∫£: **{result}**!", color=discord.Color.gold())
    embed.set_footer(text="Th·ª≠ v·∫≠n may c·ªßa b·∫°n!")
    await ctx.send(embed=embed)
    logger.info(f"K·∫øt qu·∫£ tung ƒë·ªìng xu cho ng∆∞·ªùi d√πng {ctx.author}: {result}")

# L·ªánh Game
@bot.command(name="noitu")
async def word_chain(ctx, *, word):
    """B·∫Øt ƒë·∫ßu ho·∫∑c ti·∫øp t·ª•c tr√≤ ch∆°i n·ªëi t·ª´."""
    user_id = str(ctx.author.id)
    
    if not word_chain_game.is_game_active(user_id):
        word_chain_game.start_game(user_id)
        embed = discord.Embed(title="üéÆ Tr√≤ ch∆°i N·ªëi T·ª´", description="Tr√≤ ch∆°i ƒë√£ b·∫Øt ƒë·∫ßu! H√£y nh·∫≠p m·ªôt t·ª´ c√≥ 2 ch·ªØ ƒë·ªÉ b·∫Øt ƒë·∫ßu.", color=discord.Color.green())
        await ctx.send(embed=embed)
        return

    if len(word.split()) != 2:
        embed = discord.Embed(title="‚ùå L·ªói", description="Vui l√≤ng nh·∫≠p m·ªôt t·ª´ c√≥ ƒë√∫ng 2 ch·ªØ.", color=discord.Color.red())
        await ctx.send(embed=embed)
        return

    if word_chain_game.is_word_used(user_id, word):
        embed = discord.Embed(title="‚ùå L·ªói", description="T·ª´ n√†y ƒë√£ ƒë∆∞·ª£c s·ª≠ d·ª•ng. Vui l√≤ng ch·ªçn m·ªôt t·ª´ kh√°c.", color=discord.Color.red())
        await ctx.send(embed=embed)
        return

    word_chain_game.add_used_word(user_id, word)

    try:
        bot_response = await generate_word_chain_response(word)
        if word_chain_game.is_valid_word(word, bot_response):
            word_chain_game.add_used_word(user_id, bot_response)
            embed = discord.Embed(title="ü§ñ Bot tr·∫£ l·ªùi", description=f"T·ª´ c·ªßa bot: **{bot_response}**", color=discord.Color.blue())
            embed.set_footer(text="Nh·∫≠p t·ª´ ti·∫øp theo c·ªßa b·∫°n b·∫±ng l·ªánh /noitu")
            await ctx.send(embed=embed)
        else:
            embed = discord.Embed(title="üèÜ B·∫°n th·∫Øng!", description="Bot kh√¥ng th·ªÉ t√¨m ƒë∆∞·ª£c t·ª´ ph√π h·ª£p. B·∫°n ƒë√£ chi·∫øn th·∫Øng!", color=discord.Color.gold())
            await ctx.send(embed=embed)
            word_chain_game.stop_game(user_id)
    except Exception as e:
        logger.error(f"L·ªói trong tr√≤ ch∆°i n·ªëi t·ª´: {str(e)}")
        embed = discord.Embed(title="‚ùå L·ªói", description="ƒê√£ x·∫£y ra l·ªói trong tr√≤ ch∆°i. Vui l√≤ng th·ª≠ l·∫°i sau.", color=discord.Color.red())
        await ctx.send(embed=embed)

@bot.command(name="stopnoitu")
async def stop_word_chain(ctx):
    """D·ª´ng tr√≤ ch∆°i n·ªëi t·ª´."""
    user_id = str(ctx.author.id)
    if word_chain_game.is_game_active(user_id):
        word_chain_game.stop_game(user_id)
        embed = discord.Embed(title="üõë D·ª´ng tr√≤ ch∆°i", description="Tr√≤ ch∆°i N·ªëi T·ª´ ƒë√£ ƒë∆∞·ª£c d·ª´ng l·∫°i.", color=discord.Color.red())
        embed.set_footer(text="B·∫°n c√≥ th·ªÉ b·∫Øt ƒë·∫ßu m·ªôt tr√≤ ch∆°i m·ªõi b·∫±ng l·ªánh /noitu")
        await ctx.send(embed=embed)
    else:
        embed = discord.Embed(title="‚ùì Kh√¥ng c√≥ tr√≤ ch∆°i", description="B·∫°n ch∆∞a b·∫Øt ƒë·∫ßu tr√≤ ch∆°i N·ªëi T·ª´ n√†o.", color=discord.Color.yellow())
        embed.set_footer(text="S·ª≠ d·ª•ng /noitu ƒë·ªÉ b·∫Øt ƒë·∫ßu m·ªôt tr√≤ ch∆°i m·ªõi")
        await ctx.send(embed=embed)

# L·ªánh Admin
def is_admin():
    async def predicate(ctx):
        return await bot.is_owner(ctx.author) or ctx.author.guild_permissions.administrator
    return commands.check(predicate)

@bot.command(name="shutdown")
@is_admin()
async def shutdown(ctx):
    """T·∫Øt bot (Ch·ªâ d√†nh cho ch·ªß s·ªü h·ªØu ho·∫∑c admin)."""
    embed = discord.Embed(title="üîå T·∫Øt bot", description="ƒêang t·∫Øt bot...", color=discord.Color.red())
    embed.set_footer(text="Bot s·∫Ω ng·ª´ng ho·∫°t ƒë·ªông sau khi l·ªánh n√†y ƒë∆∞·ª£c th·ª±c hi·ªán.")
    await ctx.send(embed=embed)
    logger.warning(f"Bot ƒë∆∞·ª£c t·∫Øt b·ªüi {ctx.author}")
    await bot.close()

@bot.command(name="kick")
@commands.has_permissions(kick_members=True)
async def kick(ctx, member: discord.Member, *, reason=None):
    """Kick m·ªôt th√†nh vi√™n kh·ªèi server."""
    await member.kick(reason=reason)
    embed = discord.Embed(title="üë¢ Kick th√†nh vi√™n", description=f"{member.mention} ƒë√£ b·ªã kick. L√Ω do: {reason}", color=discord.Color.orange())
    embed.set_footer(text="H√†nh ƒë·ªông n√†y ƒë√£ ƒë∆∞·ª£c ghi l·∫°i.")
    await ctx.send(embed=embed)
    logger.info(f"{member} ƒë√£ b·ªã kick b·ªüi {ctx.author}. L√Ω do: {reason}")

@bot.command(name="ban")
@commands.has_permissions(ban_members=True)
async def ban(ctx, member: discord.Member, *, reason=None):
    """Ban m·ªôt th√†nh vi√™n kh·ªèi server."""
    await member.ban(reason=reason)
    embed = discord.Embed(title="üî® Ban th√†nh vi√™n", description=f"{member.mention} ƒë√£ b·ªã ban. L√Ω do: {reason}", color=discord.Color.red())
    embed.set_footer(text="H√†nh ƒë·ªông n√†y ƒë√£ ƒë∆∞·ª£c ghi l·∫°i.")
    await ctx.send(embed=embed)
    logger.info(f"{member} ƒë√£ b·ªã ban b·ªüi {ctx.author}. L√Ω do: {reason}")

@bot.command(name="warning")
@commands.has_permissions(manage_messages=True)
async def warning(ctx, member: discord.Member, *, reason):
    """C·∫£nh c√°o m·ªôt th√†nh vi√™n."""
    embed = discord.Embed(title="‚ö†Ô∏è C·∫£nh c√°o", description=f"{member.mention} ƒë√£ b·ªã c·∫£nh c√°o. L√Ω do: {reason}", color=discord.Color.yellow())
    embed.set_footer(text="ƒê√¢y l√† m·ªôt c·∫£nh b√°o ch√≠nh th·ª©c. Vui l√≤ng tu√¢n th·ªß quy t·∫Øc server.")
    await ctx.send(embed=embed)
    logger.info(f"{member} ƒë√£ b·ªã c·∫£nh c√°o b·ªüi {ctx.author}. L√Ω do: {reason}")

@bot.command(name="say")
@is_admin()
async def say(ctx, *, message):
    """L√†m cho bot n√≥i ƒëi·ªÅu g√¨ ƒë√≥ (Ch·ªâ d√†nh cho ch·ªß s·ªü h·ªØu ho·∫∑c admin)."""
    await ctx.message.delete()
    await ctx.send(message)
    logger.info(f"Bot ƒë√£ n√≥i: '{message}' theo y√™u c·∫ßu c·ªßa {ctx.author}")

@bot.command(name="embed")
@is_admin()
async def embed(ctx, *, message):
    """G·ª≠i m·ªôt tin nh·∫Øn nh√∫ng (Ch·ªâ d√†nh cho ch·ªß s·ªü h·ªØu ho·∫∑c admin)."""
    embed = discord.Embed(description=message, color=discord.Color.random())
    embed.set_footer(text=f"Tin nh·∫Øn ƒë∆∞·ª£c g·ª≠i b·ªüi {ctx.author}")
    await ctx.send(embed=embed)
    logger.info(f"Tin nh·∫Øn nh√∫ng ƒë∆∞·ª£c g·ª≠i b·ªüi {ctx.author}")

@bot.command(name="reload")
@is_admin()
async def reload(ctx, extension):
    """T·∫£i l·∫°i m·ªôt ph·∫ßn m·ªü r·ªông c·ªßa bot (Ch·ªâ d√†nh cho ch·ªß s·ªü h·ªØu ho·∫∑c admin)."""
    try:
        await bot.reload_extension(f"cogs.{extension}")
        embed = discord.Embed(title="üîÑ T·∫£i l·∫°i ph·∫ßn m·ªü r·ªông", description=f"Ph·∫ßn m·ªü r·ªông {extension} ƒë√£ ƒë∆∞·ª£c t·∫£i l·∫°i.", color=discord.Color.green())
        embed.set_footer(text="C√°c thay ƒë·ªïi ƒë√£ ƒë∆∞·ª£c √°p d·ª•ng.")
        await ctx.send(embed=embed)
        logger.info(f"Ph·∫ßn m·ªü r·ªông {extension} ƒë√£ ƒë∆∞·ª£c t·∫£i l·∫°i b·ªüi {ctx.author}")
    except commands.ExtensionError as e:
        embed = discord.Embed(title="‚ùå L·ªói t·∫£i l·∫°i", description=f"ƒê√£ x·∫£y ra l·ªói khi t·∫£i l·∫°i {extension}: {e}", color=discord.Color.red())
        embed.set_footer(text="Vui l√≤ng ki·ªÉm tra l·∫°i t√™n ph·∫ßn m·ªü r·ªông v√† th·ª≠ l·∫°i.")
        await ctx.send(embed=embed)
        logger.error(f"L·ªói khi t·∫£i l·∫°i ph·∫ßn m·ªü r·ªông {extension}: {str(e)}")

@bot.command(name="sendcontact")
@is_admin()
async def send_contact(ctx, user: discord.User, *, message):
    """G·ª≠i tin nh·∫Øn tr·ª±c ti·∫øp ƒë·∫øn m·ªôt ng∆∞·ªùi d√πng (Ch·ªâ d√†nh cho ch·ªß s·ªü h·ªØu ho·∫∑c admin)."""
    try:
        await user.send(message)
        embed = discord.Embed(title="‚úâÔ∏è G·ª≠i tin nh·∫Øn", description=f"ƒê√£ g·ª≠i tin nh·∫Øn ƒë·∫øn {user.name}.", color=discord.Color.green())
        embed.set_footer(text="Tin nh·∫Øn ƒë√£ ƒë∆∞·ª£c g·ª≠i th√†nh c√¥ng.")
        await ctx.send(embed=embed)
        logger.info(f"Tin nh·∫Øn ƒë∆∞·ª£c g·ª≠i ƒë·∫øn {user.name} b·ªüi {ctx.author}")
    except discord.Forbidden:
        embed = discord.Embed(title="‚ùå L·ªói g·ª≠i tin nh·∫Øn", description=f"Kh√¥ng th·ªÉ g·ª≠i tin nh·∫Øn ƒë·∫øn {user.name}. H·ªç c√≥ th·ªÉ ƒë√£ t·∫Øt DM.", color=discord.Color.red())
        embed.set_footer(text="Vui l√≤ng ki·ªÉm tra c√†i ƒë·∫∑t quy·ªÅn ri√™ng t∆∞ c·ªßa ng∆∞·ªùi d√πng.")
        await ctx.send(embed=embed)
        logger.error(f"Kh√¥ng th·ªÉ g·ª≠i tin nh·∫Øn ƒë·∫øn {user.name}. Ng∆∞·ªùi d√πng c√≥ th·ªÉ ƒë√£ t·∫Øt DM.")

@bot.event
async def on_command_error(ctx, error):
    if isinstance(error, commands.CommandNotFound):
        embed = discord.Embed(title="‚ùì L·ªói l·ªánh", description="Kh√¥ng t√¨m th·∫•y l·ªánh. S·ª≠ d·ª•ng `/helpme` ƒë·ªÉ xem danh s√°ch c√°c l·ªánh c√≥ s·∫µn.", color=discord.Color.red())
        embed.set_footer(text="Ki·ªÉm tra l·∫°i ch√≠nh t·∫£ c·ªßa l·ªánh v√† th·ª≠ l·∫°i.")
        await ctx.send(embed=embed)
    elif isinstance(error, commands.MissingRequiredArgument):
        embed = discord.Embed(title="‚ö†Ô∏è L·ªói l·ªánh", description="Thi·∫øu tham s·ªë b·∫Øt bu·ªôc. Vui l√≤ng ki·ªÉm tra c√∫ ph√°p l·ªánh.", color=discord.Color.yellow())
        embed.set_footer(text="S·ª≠ d·ª•ng /helpme <l·ªánh> ƒë·ªÉ xem c√°ch s·ª≠ d·ª•ng l·ªánh.")
        await ctx.send(embed=embed)
    elif isinstance(error, commands.CheckFailure):
        embed = discord.Embed(title="üö´ L·ªói quy·ªÅn h·∫°n", description="B·∫°n kh√¥ng c√≥ quy·ªÅn s·ª≠ d·ª•ng l·ªánh n√†y.", color=discord.Color.red())
        embed.set_footer(text="Li√™n h·ªá v·ªõi qu·∫£n tr·ªã vi√™n n·∫øu b·∫°n c·∫ßn quy·ªÅn truy c·∫≠p.")
        await ctx.send(embed=embed)
    else:
        embed = discord.Embed(title="‚ùå L·ªói kh√¥ng x√°c ƒë·ªãnh", description="ƒê√£ x·∫£y ra l·ªói khi th·ª±c hi·ªán l·ªánh. Vui l√≤ng th·ª≠ l·∫°i sau.", color=discord.Color.red())
        embed.set_footer(text="N·∫øu l·ªói v·∫´n ti·∫øp t·ª•c, h√£y b√°o c√°o cho ƒë·ªôi ng≈© ph√°t tri·ªÉn.")
        await ctx.send(embed=embed)
        logger.error(f"L·ªói l·ªánh kh√¥ng x·ª≠ l√Ω ƒë∆∞·ª£c: {str(error)}")

# H√†m h·ªó tr·ª£
def get_context(user_id):
    if user_id not in short_term_memory:
        short_term_memory[user_id] = deque(maxlen=5)
    context = "\n".join(short_term_memory[user_id])
    
    cursor.execute("SELECT context FROM long_term_memory WHERE user_id = ? ORDER BY timestamp DESC LIMIT 1", (user_id,))
    long_term_context = cursor.fetchone()
    if long_term_context:
        context = f"{long_term_context[0]}\n\n{context}"
    
    return context

def update_memory(user_id, user_message, bot_response):
    if user_id not in short_term_memory:
        short_term_memory[user_id] = deque(maxlen=5)
    short_term_memory[user_id].append(f"Ng∆∞·ªùi d√πng: {user_message}")
    short_term_memory[user_id].append(f"Tr·ª£ l√Ω AI: {bot_response}")
    
    context = "\n".join(short_term_memory[user_id])
    cursor.execute("INSERT INTO long_term_memory (user_id, context) VALUES (?, ?)", (user_id, context))
    conn.commit()

# Ch·∫°y bot
bot.run('MTMzNDQzMzAyNjA5NTk3NjYxMg.GuSbOl.OjZQpo4S9WAjkedl6obWoPAy9yjMDt8tQx1zfM')

